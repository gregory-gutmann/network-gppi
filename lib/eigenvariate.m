%% Extract Timeseries Data from all ROI(s)% Gregory Gutmann (15.11.22)%{Heavily based on timeseries_extract.m script written by Donald G. McLarenand Aaron Schulz (part of PPPI-package). Also, samples of code was taken from set_mask.m written by Donald G. McLaren and Aaron Schulz (part of PPPI-package). As roi-masks were already realigned, it was possible to rewrite and simplify certain parts. Comments were added for clarity.    $Id: timeseries_extract.m    $Id: set_mask.m    Copyright (c) 2011, Donald G. McLaren and Aaron Schultz    (Harvard Aging Brain Project)%}function xY = eigenvariate(fstFolder,ntwFolder,contAdj,roiList,roiSubFolder)% Create result folderif ~exist([ntwFolder, 'eigenvariates'])    mkdir([ntwFolder, 'eigenvariates']);end% Set-upload([fstFolder, 'SPM.mat']);sessions        = numel(SPM.Sess);% Iterate over sessionsfor sess=1:sessions    % Iterate over regions    for r=1:length(roiList)                % Select specific regions and shorten adapt ROI name        roi             = roiList{r};        roiName         = roi(1:(length(roi)-4));               % Creats header for mask image in xY.name and save name        clear xY        xY.mask         = spm_vol([roiSubFolder,roi]);        xY.name         = roiName;        % Read in mask image and save coordinates of non-zero or non-        % empty values         [img,xY.XYZmm]  = spm_read_vols(xY.mask);        xY.XYZmm        = xY.XYZmm(:,(~isnan(img) & img>0));        clear img        % Number of voxel within mask        numvox          = size(xY.XYZmm,2);                % Empty mask header of unwanted variables and include session        % number and contrast to adjust for        clear xY.y xY.yy xY.u xY.v xY.s xY.X0        xY.Sess         = sess;        xY.Ic           = contAdj;                     % Tranform real-size coordinates (mm) into matrix coordinates (number)        xY.XYZ = inv(xY.mask.mat)*[xY.XYZmm;ones(1,size(xY.XYZmm,2))];        xY.XYZ = xY.XYZ(1:3,:);        %% For seed-eigenvariate        % (spm_regions.m was the source of most of the code below)        % Get timeseries of relevant voxel (based on coordinates)        y               = spm_get_data(SPM.xY.VY,xY.XYZ);        % Remove frequency noise with highpass filtering (SPM.xX.K)        % and prewhitening (SPM.xX.W) (see end for more information)        y               = spm_filter(SPM.xX.K,SPM.xX.W*y);        % Load in beta values for relevant voxel (directory must be change         % and then changed back) for cofound removal        tmpdir          = pwd;        cd(SPM.swd)        beta            = spm_get_data(SPM.Vbeta,xY.XYZ);        cd(tmpdir)                % Removal of cofounds of no interest        % (subtract Y0 = XO*beta for  Y = Yc + Y0 + e)        % SPM.xX.xKXs: space structure for K*W*X, the 'filtered and whitened'        % design matrix (used instead of unchanged design matrix)        if xY.Ic~=0            y = y-spm_FcUtil('Y0',SPM.xCon(xY.Ic),SPM.xX.xKXs,beta);        end        % Select particular session for y        % Also, save in xY.X0 whitened and filtered session vector as         % well as frequency cofounds for the respective session        [xY,y]          = get_confounds(SPM,xY,y);                % Compute regional response in terms of first eigenvariate        % based on singular value decomposition        [m n]   = size(y);        if m > n            [v s v]         = svd(y'*y);            s               = diag(s);            v               = v(:,1);            u               = y*v/sqrt(s(1));        else            [u s u]         = svd(y*y');            s               = diag(s);            u               = u(:,1);            v               = y'*u/sqrt(s(1));        end        d               = sign(sum(v));        u               = u*d;        v               = v*d;        Y               = u*sqrt(s(1)/n);                % Define output structure        xY.y                = y; % Timeseries of voxel        xY.yy               = transpose(mean(transpose(y))); % Average        xY.u                = Y; % Eigenvariate        xY.v                = v;        xY.s                = s;                %% For target-eigenvariate (without subtract Y0 = XO*beta)                % Get timeseries of relevant voxel (based on coordinates)        yt              = spm_get_data(SPM.xY.VY,xY.XYZ);        % Select particular session for y (see above)        [xY,yt]         = get_confounds(SPM,xY,yt);        % Compute regional response in terms of first eigenvariate        % based on singular value decomposition        [m n]   = size(yt);        if m > n            [v s v]         = svd(yt'*yt);            s               = diag(s);            v               = v(:,1);            u               = yt*v/sqrt(s(1));        else            [u s u]         = svd(yt*yt');            s               = diag(s);            u               = u(:,1);            v               = yt'*u/sqrt(s(1));        end        d               = sign(sum(v));        u               = u*d;        v               = v*d;        Yt              = u*sqrt(s(1)/n);        % Define output structure        xY.yt               = yt; % Timeseries of voxel        xY.yyt              = transpose(mean(transpose(yt))); % Average        xY.t                = Yt; % Eigenvariate        xY.vt               = v;        xY.st               = s;             % save        resultFolder    = [ntwFolder,'eigenvariates',filesep];        save([resultFolder,roiName,'_sess_',num2str(sess)],'xY', '-v6');                clear xY XYZ hdr img beta y d u v Y s    endend%{%% Remove frequency noise with highpass filtering (SPM.xX.K)%% and prewhitening (SPM.xX.W) SPM.xX.K: low frequency confounds as cosinus curves (high-pass cutoff)   - Removes cofounds frequencies with wavelength >= defined  in first level analysis (e.g. 128 s) and session lengthSPM.xX.W: Whitening/weighting matrix used to give weighted   least squares estimates  - Adjust for frequency noise by controlling  temporal autocorrelation (especially high-frequency?)First whithening and then filtering relevant?? Revers order justminor differenceNote: No notable difference between filtering and whitening timeseriesbefore computing eigenvariate of filtering and whitening timeserieseigenvarita itself%}